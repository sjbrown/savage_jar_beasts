<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>sjbrown's Guide To Writing Games</title>

<style type="text/css">
body {  font-family: sans-serif; margin-top: 5px; margin-bottom: 1em}
pre.python   { text-align: left; padding: 0px}
pre.python b { color: blue; font-weight: normal; }
.diversion {
        margin: 2em;
        padding-left: 1em;
        border-left: solid black thin;
}
.codeblock   { 
        background-color: #F0F0FF; 
        padding: 1em; 
        width: 70%; 
        margin: 0.8em;
        border: dashed 1px #D0D0FF;
}
.snippet { 
        background-color: #E9E9F0; 
        padding: 0.5em; 
        width: 70%; 
        margin: 0.5em 
}
.console {
        border: solid thin #aaaaaa;
        margin: 1ex;
        padding: 5px;
        text-align: center;
        float: left;
}
.clear {
        clear: both;
}
pre.bash { 
        padding: 8px;
        text-align: left; 
        padding: 0px;
        color: white;
        background-color: black;
        width: 80ex;
}
.sourceLinks {
        border: solid thin #0000FF;
        margin: 1em;
        padding: 1em;
}
.todo {
        color: #AA6699;
}
img.internal {
        float: left;
        vertical-align: middle;
        margin-right: 0.5em;
        margin-bottom: 1em;
}
h3 { clear: both; }
li.q { font-weight: bold; list-style-type: disc;}
li.a { padding-bottom: 1em; list-style-type: circle;}
</style>
</head>
<body>
<b style="color:red">NOTE: this tutorial is currently "in-progress". It's not
done, but it covers a lot of ground and is "useful" in it's current state</b>
<p>please send comments / corrections via email to shandy AT geeky DOT net</p>
<p>I guess there's a lot of traffic hitting this right now, so I might as well
mention that I'm looking for work. If anyone knows any company that's looking
to <b>hire a software developer</b>, my resume is at <a href=
"http://resume.ezide.com/">resume.ezide.com</a></p>
<p><b style="color:blue">Last Update:</b> Added another section to the networking part; January 11, 2004
</p>
<hr>
<a href="table.html">Table Of Contents</a>
<hr>
<h1><a name="purpose">Purpose</a></h1>
<span class="todo">[TODO]</span>
<h1><a name="twitch">Twitch vs. Non-Twitch</a></h1>
First of all, let me say what this guide is <b>not</b>. Some games you may be
used to playing are known as "Twitch" games. In these games the speed by which
you press the buttons or move your mouse have an effect on the outcome of the
game. In "Street Fighter", if you press your punch button a couple miliseconds
before your opponent, it can matter.
<p>This guide will not be dealing with such games. Some (perhaps all) of the
ideas covered here may be applicable to Twitch games, but that is not the
focus. This guide is most appliccable to games where it is acceptable to have
a slight (if imperceptable) lag between user input and screen response.</p>
<p>Now, some might be thinking "Oh, this doesn't apply to me then, I want to
make a Shooter / Real Time Strategy / etc.". However those kind of games might
not be "Twitch" games. I recommend going ahead and trying to use this Guide.
You'll have a better idea later if your game has such dire latency
requirements.</p>
<h1><a name="know">What You Should Know</a></h1>
This guide assumes a certain level of knowledge. If it is confusing, perhaps
you should brush up on some of these concepts.
<h2><a name="oop">Object Oriented Programming</a></h2>
It is expected the reader is comfortable in an object oriented environment.
All important parts are encapsulated into classes.
<h2><a name="patterns">Design Patterns</a></h2>
This guide makes use of the Design Patterns "Model View Controller" (MVC) and
"Observer". If this sounds foreign to you, I reccommend checking out the book
"Design Patterns" by Gamma et al. or just surfing the web for tutorials. You
may be able to follow along without having previous exposure to Design
Patterns, as their purpose is quickly evident to people familiar with Object
Oriented programming.
<h1><a name="part1">PART 1</a></h1>
<h1><a name="example">Example Goal</a></h1>
It's always a good idea to sketch out your game either with pictures or text
before you begin coding.
<p>We will start by trying to create a program where a little man moves around
a grid of nine squares. This is a overly simple example, but easily extendable
so we won't get tied up in the game rules, instead we can focus on the
structure of the code.</p>
<center><img src="mockup.png" alt="example applicaton" width="400" height=
"400"></center>
<h1><a name="architecture">The Architecture</a></h1>
<h2><a name="mvc">Model View Controller</a></h2>
The choice of MVC should be pretty obvious where a graphical game is
concerned. The primary Model will be discussed later under the heading
<a href="#hModel">The Game Model</a>. The primary View will be a PyGame window
displaying graphics on the monitor. The primary Controller will be the
keyboard, supported by PyGame's internal pygame.event module.
<p>We haven't even got to the Model yet, and already we have a difficulty. If
you are familiar with using PyGame, you are probably used to seeing a main
loop like this:</p>
<div class="codeblock">
<pre class="python">
 <b>#<i>stolen from the ChimpLineByLine example at pygame.org</i></b>
 main():
    ...
    while 1:

        <b>#Handle Input Events</b>
        for event in pygame.event.get():
            if event.type == QUIT:
                return
            elif event.type == MOUSEBUTTONDOWN:
                fist.punch()
            elif event.type is MOUSEBUTTONUP:
                fist.unpunch()

        <b>#Draw Everything</b>
        allsprites.update()
        screen.blit(background, (0, 0))
        allsprites.draw(screen)
        pygame.display.flip()
</pre></div>
In this example, the Controller (the "Handle Input Events" part) and the View
(the "Draw Everything" part) are tightly coupled, and this is generally how
PyGame works, at every iteration of the main loop, it is expected that we will
check for input events, update all the visible sprites, and redraw the screen.
However the MVC pattern requires the View and the Controller to be separate.
Our solution is to introduce a Tick() function that the constantly looping
main loop can call for both the View and the Controller. That way there will
not be View-specific code in the same location as Controller-specific code.
Here is a rough example:
<div class="codeblock">
<pre class="python">
 ControllerTick():
    <b>#Handle Input Events</b>
    for event in pygame.event.get():
        if event.type == QUIT:
            return 0
        elif event.type == MOUSEBUTTONDOWN:
            fist.punch()
        elif event.type is MOUSEBUTTONUP:
            fist.unpunch()
    return 1

 ViewTick():
    <b>#Draw Everything</b>
    ...

 main():
    ...
    while 1:

        if ControllerTick() == 0:
            return

        ViewTick()
</pre></div>
Here is some more info on the MVC pattern: <a href=
"http://ootips.org/mvc-pattern.html">http://ootips.org/mvc-pattern.html</a>
<h2><a name="observer">Observer</a></h2>
Let's examine the infinite while loop in the last bit of code. What is it's
job? It basically sends the Tick() message out to the View and the Controller
as fast as the CPU can manage. In that sense it can be viewed as a piece of
hardware sending messages into the program, just like the keyboard; it can be
considered another Controller.
<p>Perhaps if time affects our game there will be even another Controller that
sends messages every second, or perhaps there will be another View that spits
text out to a log file. We now need to consider how we are going to handle
multiple Views and Controllers. This leads us to the next pattern in our
architecture, the Observer.</p>
<center><img src="arch.png" alt="architecture" width="256" height=
"256"></center>
<p>We implement the Observer pattern by creating an EventManager object. This
middleman will allow multiple listeners to be notified when some other object
changes state. Furthermore, that changing object doesn't need to know how many
listeners there are, they can even be added and subtracted dynamically. All
the changing object needs to do is send an Event to the EventManager when it
changes.</p>
<p>If an object wants to listen for events, it must first register itself with
the EventManager. We'll use the weakref WeakKeyDictionary so that listeners
don't have to explicitly unregister themselves.</p>
<p>We will also need an Event class to encapsulate the events that can be sent
via the EventManager.</p>
<div class="codeblock">
<pre class="python">
class Event:
        """this is a superclass for any events that might be generated by an
        object and sent to the EventManager"""
        def __init__(self):
                self.name = "Generic Event"

class EventManager:
        """this object is responsible for coordinating most communication
        between the Model, View, and Controller."""
        def __init__(self ):
                from weakref import WeakKeyDictionary
                self.listeners = WeakKeyDictionary()

        <b>#----------------------------------------------------------------------</b>
        def RegisterListener( self, listener ):
                self.listeners[ listener ] = 1

        <b>#----------------------------------------------------------------------</b>
        def UnregisterListener( self, listener ):
                if listener in self.listeners.keys():
                        del self.listeners[ listener ]
                
        <b>#----------------------------------------------------------------------</b>
        def Post( self, event ):
                for listener in self.listeners.keys():
                        <b>#NOTE: If the weakref has died, it will be </b>
                        <b>#automatically removed, so we don't have </b>
                        <b>#to worry about it.</b>
                        listener.Notify( event )
</pre></div>
Here is a rough idea how this might be integrated with the previous code.
<div class="codeblock">
<pre class="python">
class KeyboardController:
        ...
        def Notify(self, event):
                if isinstance( event, TickEvent ):
                        <b>#Handle Input Events</b>
                        ...

class CPUSpinnerController:
        ...
        def Run(self):
                while self.keepGoing:
                        event = TickEvent()
                        self.evManager.Post( event )

        def Notify(self, event):
                if isinstance( event, QuitEvent ):
                        self.keepGoing = 0
                        ...


class PygameView:
        ...
        def Notify(self, event):
                if isinstance( event, TickEvent ):
                        <b>#Draw Everything</b>
                        ...

 main():
        ...
        evManager = EventManager()

        keybd = KeyboardController()
        spinner = CPUSpinnerController()
        pygameView = PygameView()
        
        evManager.RegisterListener( keybd )
        evManager.RegisterListener( spinner )
        evManager.RegisterListener( pygameView )

        spinner.Run()
</pre></div>
<div class="diversion">
<h3><a name="selective">Diversion: Event Types and Selective
Listeners</a></h3>
As we get more and more listeners, we may find that it's inefficient to spam
every listener with every event. Perhaps some listeners only care about
certain events. One way to make things more efficient is to classify the
events into different groups.
<p>For the purpose of this guide, we'll just use one kind of event, so every
listener gets spammed with every event.</p>
</div>
Here is some more info on the Observer pattern: <a href=
"http://ootips.org/observer-pattern.html">http://ootips.org/observer-pattern.html</a>
<div class="diversion">
<h3><a name="evmanager">Advanced Event Managers</a></h3>
If you try to use this particular Event Manager class for your own project,
you might notice it has some shortcomings. In particular, if a block of code
generates events A and B sequentially, and a listener catches event A and
generates event C, the above Event Manager class will process the events in
the order A,C,B, instead of the desired order of A,B,C. In Part 3, we will see
an example of a more advanced Event Manager.</div>
<a name="hModel"></a>
<h1><a name="hModel">The Game Model</a></h1>
Here's the basic Model:
<center><img src="game-model.png" alt="example applicaton" width="269" height=
"206"></center>
<h2><a name="game">Game</a></h2>
Game is mainly a container object. It contains the Players and the Maps. It
might also do things like Start() and Finish() and keep track of whose turn it
is.
<h2><a name="player">Player</a></h2>
A Player object represents the actual human (or computer) that is playing the
game. Common attributes are Player.score and Player.color. Don't confuse it
with Charactor. Pac Man is a Charactor, the person holding the joystick is a
Player.
<h2><a name="charactor">Charactor</a></h2>
A Charactor is something controlled by a player that moves around the Map.
Synonyms might be "Unit" or "Avatar". It is intentionally spelled "Charactor"
to avoid any ambiguity with Character which can also mean "a single letter"
(also, you cannot create a table in PostgreSQL named "Character"). Common
Charactor attributes are Charactor.health and Charactor.speed.
<p>In our example, "little man" will be our sole Charactor.</p>
<h2><a name="map">Map</a></h2>
A Map is an area that Charactors can move around in. There are generally two
kinds of maps, discrete ones that have Sectors, and continuous ones that have
Locations. A chess board is an example of a discrete map. The screen in
Scorched Earth, or a level in Super Mario are examples of continuous Maps.
<p>In our example, the Map will be a discrete Map having a simple list of nine
sectors.</p>
<h2><a name="sector">Sector</a></h2>
A Sector is part of a Map. It is adjacent to other sectors of the map, and
might have a list of any such neighbors. No Charactor can be <i>in between</i>
Sectors. If a Charactor is in a Sector, it is in that sector entirely, and not
in any other Sector (I'm speaking functionally here. It can <i>look</i> like
it is in between Sectors, but that is an issue for the View, not the Model)
<p>In our example, we will allow no diagonal moves, only up, down, left and
right. Each allowable move will be defined by the list of neighbors for a
particular Sector, with the middle Sector having all four.</p>
<h2><a name="location">Location</a></h2>
We won't get into Locations of a continuous Map, as they don't apply to our
example.
<h2><a name="item">Item</a></h2>
You'll notice that Item is not explicitly connected to anything. This is left
up to the developer. You could have a design constraint that Items <b>must</b>
be contained by Charactors (perhaps in an intermidiate "Inventory" object), or
maybe it makes more sense for your game to keep a list of a bunch of Items in
the Game object. Some games might call for Sectors having Items lying around
inside them.
<h1><a name="our">Our Example</a></h1>
<div class="sourceLinks">The code can be downloaded here: <a href=
"example1.py">example1.py</a><br>
And here's some colored html: <a href=
"example1.py.html">example1.py.html</a></div>
<center><img src="screenshot-example1.png" alt="example applicaton" width=
"434" height="468"></center>
<p>This example makes use of everything covered so far. It starts out with a
list of possible events, then we define our middleman, EventManager, with all
the methods we showed earlier.</p>
<p>Next we have our Controllers, KeyboardController and CPUSpinnerController.
You'll notice keypresses no longer directly control some game object, instead
they just generate events that are sent to the EventManager. Thus we have
separated the Controller from the Model.</p>
<p>Next we have the parts of our PyGame View, SectorSprite, CharactorSprite,
and PygameView. You'll notice that SectorSprite does keep a reference to a
Sector object, part of our model. However we don't want to access any methods
of this Sector object directly, we're just using it to identify which Sector
object the SectorSprite object corresponds to. If we wanted to make this
limitation more explicit we could use the id() function.</p>
<p>The Pygame View has a background group of green square sprites that
represent the Sector objects, and a foreground group containing our "little
man" or "red dot". It is updated on every TickEvent.</p>
<p>Finally we have the Model objects as discussed above and ultimately the
main() function.</p>
<p>Here is a diagram of the major incoming and outgoing events.</p>
<center><img src="diagram-incoming.png" alt="example incoming messages" width=
"400" height="340"> <img src="diagram-outgoing.png" alt=
"example outgoing messages" width="400" height="328"></center>
<h1><a name="part2">PART 2</a></h1>
<h1><a name="internet">Internet Play</a></h1>
Our next task will be to make the game playable over the internet. Eventually
this will lead to multiplayer capability for our game, but it's important that
we do the network step first, as it exposes us to several constraints that may
affect any future code.
<p>The code in the following sections is written incrementally, so don't expect
to just take the code from the first section and write a game with it.  
Subsequent sections sometimes address problems with the previously shown code
and explain how to overcome those problems.
<h2><a name="trust">Trust</a></h2>
<h3><a name="clientserver">Client / Server</a></h3>
<span class="todo">[TODO]</span>
<h2><a name="sync">Synchronus / Asyncronus</a></h2>
<span class="todo">[TODO]</span> Regarding Twisted, a lot of the documentation
is aimed at people who are <i>only</i> going to implement the server side, or
who are going to use some common protocol like HTTP or SMTP. I reccommend
skipping parts such as "Writing a Server" and "Writing a Client" in the
Twisted docs, those sections will probably just confuse you. If you want to
understand the way we're using Twisted, skip to "Introduction to Perspective
Broker".
<p><span class="todo">[TODO: intro to twisted]</span></p>
<h2><a name="implementation">Implementation</a></h2>
<h3><a name="exServer">Example Server</a></h3>
For the server, we'll start with the exact same code as before. Just rename
example1.py to server1.py.
<p>Normally a server is something that runs as a daemon or in a text console;
it does not have a graphical display. We can do this simply by replacing
PygameView with a TextLogView as follows:</p>
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class TextLogView:
        """..."""
        def __init__(self, evManager):
                self.evManager = evManager
                self.evManager.RegisterListener( self )
                                                                               
                                                                               
        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                                                                               
                if isinstance( event, CharactorPlaceEvent ):
                        print event.name, " at ", event.charactor.sector
                                                                               
                elif isinstance( event, CharactorMoveEvent ):
                        print event.name, " to ", event.charactor.sector
                                                                               
                elif not isinstance( event, TickEvent ):
                        print event.name
</pre></div>
Now we no longer have a Pygame display, instead the TextLogView just prints
the events received out to the console.
<p>Another thing we don't need in a server is keyboard input, so we can remove
the KeyboardController. Where do input messages come from instead? They come
from the network, so we'll need a Controller object for the messages sent by
the clients, NetworkClientController.</p>
<div class="codeblock">
<pre class="python">
from twisted.spread import pb
#------------------------------------------------------------------------------
class NetworkClientController(pb.Root):
        """..."""
        def __init__(self, evManager):
                self.evManager = evManager
                self.evManager.RegisterListener( self )

        #----------------------------------------------------------------------
        def remote_GameStartRequest(self):
                ev = GameStartRequest( )
                self.evManager.Post( ev )
                return 1

        #----------------------------------------------------------------------
        def remote_CharactorMoveRequest(self, direction):
                ev = CharactorMoveRequest( direction )
                self.evManager.Post( ev )
                return 1

        #----------------------------------------------------------------------
        def Notify(self, event):
                pass
</pre></div>
The NetworkClientController instance is a special object that can be sent
across the network via Twisted's Perspective Broker mechanism (because it
inherits from pb.Root). The remote client will request a reference to the
NetworkClientController instance, once it has received it, it can call any
method that starts with "remote_". So for the client to send messages to the
server, we have implemented remote_GameStartRequest and
remote_CharactorMoveRequest.
<div class="diversion">
<h3><a name="caveat">Caveat</a></h3>
It could be tempting to make all of the objects remotely referenceable. (ie,
inherit from pb.Referenceable) The problem with that approach is that it
tightly couples the networking code with the rest of the code. It's preferable
to separate the networking code so that the other objects just use the event
passing strategy described by the Observer pattern.
<p>In our examples, we're only going to have one class in the server that is
referenceable, and also only one class in the client. <span class=
"todo">[TODO: expand on this]</span></p>
</div>
<p>Note: we also don't need the CPUSpinnerController in the server, so we've
removed that. Previously, we used the Tick event to start the Game, now we'll
need to explicitly start the game with our new GameStartRequest event.</p>
<div class="codeblock">
<pre class="python">
class GameStartRequest(Event):
        def __init__(self):
        self.name = "Game Start Request"
</pre></div>
The spinner is no longer running our mainloop, instead Twisted is in charge.
<div class="codeblock">
<pre class="python">
def main():
        """..."""
        evManager = EventManager()

        log = TextLogView( evManager )
        clientController = NetworkClientController( evManager )
        game = Game( evManager )
        
        from twisted.internet.app import Application

        application = Application("myServer")
        application.listenTCP(8000, pb.BrokerFactory(clientController) )

        application.run()
</pre></div>
It is not necessary for you to understand the Twisted parts of this, you can
just consider them "magic". What you should know is that invoking
application.run() causes the mainloop to block while listening on port 8000.
Using Twisted's Application class gives us several convenient features "for
free". We'll discuss them later.
<p><span class="todo">[TODO: make it more clear that this is merely a
toy]</span></p>
<p>Here's an example of the server responding to a fake client.</p>
<div class="console">
<pre class="bash">
 $ python
 Python 2.2.1 (#1, Aug 30 2002, 12:15:30)
 [GCC 3.2 20020822 (Red Hat Linux Rawhide 3.2-4)] on linux2
 Type "help", "copyright", "credits" or "license" for more information.
 &gt;&gt;&gt; from twisted.spread import pb
 &gt;&gt;&gt; from twisted.internet import reactor
 &gt;&gt;&gt;
 &gt;&gt;&gt; class Connection:
 ...     def connected(self, object):
 ...         self.obj = object
 ...         print "got object: ", self.obj
 ...
 &gt;&gt;&gt; conn = Connection()
 &gt;&gt;&gt; remoteResponse = pb.getObjectAt("localhost", 8000, 30)
 &gt;&gt;&gt; remoteResponse.addCallbacks(conn.connected)
 &lt;Deferred at 0x819b9fc&gt;
 &gt;&gt;&gt; reactor.iterate()
 &gt;&gt;&gt; reactor.iterate()
 got object:  &lt;twisted.spread.pb.RemoteReference instance at 0x83964ec&gt;
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("GameStartRequest")
 &gt;&gt;&gt; up,down,left,right = 0,1,2,3
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("CharactorMoveRequest", up)
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("CharactorMoveRequest", up)
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("CharactorMoveRequest", left)
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("CharactorMoveRequest", down)
 &gt;&gt;&gt; remoteResponse = conn.obj.callRemote("CharactorMoveRequest", right)
 &gt;&gt;&gt;
</pre>
Example of using the Python console as a fake client</div>
<div class="console">
<pre class="bash">
 $ python server1.py
 Map Finished Building Event
 Charactor Placement Event  at  &lt;__main__.Sector instance at 0x81e9bec&gt;
 Game Started Event
 Game Start Request
 Charactor Move Request
 Charactor Move Request
 Charactor Move Request
 Charactor Move Event  to  &lt;__main__.Sector instance at 0x81e9e94&gt;
 Charactor Move Request
 Charactor Move Event  to  &lt;__main__.Sector instance at 0x81e9f6c&gt;
 Charactor Move Request
</pre>
Running server1.py</div>
<p class="clear">&nbsp;</p>
<div class="sourceLinks">The code for server1.py can be downloaded here:
<a href="server1.py">server1.py</a><br>
And here's some colored html: <a href=
"server1.py.html">server1.py.html</a></div>
<h2><a name="wire">Messages Over the Wire</a></h2>
<div class="sourceLinks">The source code to the remainder of this section are
in multiple files. You can download them in tar.gz format here: <a href=
"simple.tar.gz">simple.tar.gz</a></div>
<p>The previous example of a server gave a good introduction to the basic
networking technique, but it's a little too simple for our purposes. We don't
really want to write a new function for every message the server can possibly
receive. Instead, we'd like to leverage our already existing Event
classes.</p>
<p>This brings us to one of the most important parts, but possibly the most
tedious part of implementing networking. We need to go through all the
possible events and answer these questions about each:</p>
<ol>
<li>Do we need to send it from the client to the server?</li>
<li>Do we need to send it from the server to the client?</li>
<li>Are there security issues with sending this data over the network?</li>
<li>Is the data formatted in a way that it can be sent over the network?</li>
<li>If we must, how do we reformat the data so that it can be sent?</li>
</ol>
(Eventually, one might also ask "How often will this message be sent?" and
therefore "How can i best optimise this message?")
<p>While there are many ways of doing this with Twisted, I will outline a
strategy that tries to minimize the amount of code written (to combat the
tediousness of this task) and to maintain the separation of the networking
requirements from the remainder of the code.</p>
<p>Using Twisted, we must do three things to a class to make it possible to
send it over the network: make it inherit from twisted.spread.pb.Copyable,
make it inherit from twisted.spread.pb.RemoteCopy, and call
twisted.spread.pb.setUnjellyableForClass() on it <span class="todo">[TODO: ask
someone who knows Twisted if that's <b>really</b> necessary].</span> Things
can become even <i>more</i> complicated when we consider questions 4 and 5
from our list above -- does the data requires special formatting to send it
over the network? The only data that <b>doesn't</b> require special formatting
are the "built-in" types: int, string, list, tuple, and dict.</p>
<p>While examining the Events, two cases will occur, either it will not
require reformatting, and we can just mix-in pb.Copyable and pb.RemoteCopy, or
it will require reformatting and we will have to create a new class that has a
routine to change the original data into something that can be sent over the
network. <span class="todo">[TODO: link to explain Mixins
somewhere]</span></p>
<p>In this next example, we've split the code into multiple files. All the
events are in events.py. In network.py, we try to answer all of the above
questions for each event in events.py. If a message can go from the client to
the server, we append it to the clientToServerEvents list, and likewise for
the serverToClientEvents list. If the data in the event is simple, like
integers and strings, then we can just mix-in the pb.Copyable and
pb.RemoteCopy classes and call pb.setUnjellyableForClass() on the event.</p>
<div class="codeblock">
<pre class="python">
<b># from network.py</b>

<b>#------------------------------------------------------------------------------</b>
<b># GameStartRequest</b>
<b># Direction: Client to Server only</b>
MixInCopyClasses( GameStartRequest )
pb.setUnjellyableForClass(GameStartRequest, GameStartRequest)
clientToServerEvents.append( GameStartRequest )

#------------------------------------------------------------------------------
<b># CharactorMoveRequest</b>
<b># Direction: Client to Server only</b>
<b># this has an additional attribute, direction.  it is an int, so it's safe</b>
MixInCopyClasses( CharactorMoveRequest )
pb.setUnjellyableForClass(CharactorMoveRequest, CharactorMoveRequest)
clientToServerEvents.append( CharactorMoveRequest )
</pre></div>
<p>On the other hand, if an event contains data that is not network-friendly,
like an object, we need to make a replacement event to send over the wire
instead of the original. The simplest way to make a replacement is just to
change any event attributes that were objects to unique integers using the
id() function. This strategy requires us to keep a registry of objects and
their ID numbers, so that when we recieve an event from the network
referencing an object by its ID number, we can find the actual object.</p>
<div class="codeblock">
<pre class="python">
<b># from network.py</b>

<b>#------------------------------------------------------------------------------</b>
<b># GameStartedEvent</b>
<b># Direction: Server to Client only</b>
class CopyableGameStartedEvent(pb.Copyable, pb.RemoteCopy):
        def __init__(self, event, registry):
                self.name = "Game Started Event"
                self.gameID =  id(event.game)
                registry[self.gameID] = event.game

pb.setUnjellyableForClass(CopyableGameStartedEvent, CopyableGameStartedEvent)
serverToClientEvents.append( CopyableGameStartedEvent )

<b>#------------------------------------------------------------------------------</b>
<b># CharactorMoveEvent</b>
<b># Direction: Server to Client only</b>
class CopyableCharactorMoveEvent( pb.Copyable, pb.RemoteCopy):
        def __init__(self, event, registry ):
                self.name = "Charactor Move Event"
                self.charactorID = id( event.charactor )
                registry[self.charactorID] = event.charactor

pb.setUnjellyableForClass(CopyableCharactorMoveEvent, CopyableCharactorMoveEvent)
serverToClientEvents.append( CopyableCharactorMoveEvent )
</pre></div>
It is very important that these classes are named exactly the same as the
class they're replacing but with a prefix of "Copyable" (we'll see why later).
We can see how to replace the original events with these network-friendly
versions in NetworkClientView.Notify in server2.py and we can see how the
receipt of these events is handled in PhonyModel.Notify in client2.py.
<h3><a name="channel">Creating A Communication Channel</a></h3>
We've seen that we can send fake messages to the server via an interactive
python shell, but what we really want is a graphical client. There are a few
steps to realizing this goal. Firstly, the client(s) need to be notified of
any changes to the state of the server. So we'll need bidirectional
communication. Not only does the client send requests to the server, but the
server also notifies the client of events. (This is why one-way protocols like
XML-RPC or HTTP are not well suited to our needs)
<p>From the server, changes need to be sent out, so we need to create a new
View on the server.</p>
<div class="codeblock">
<pre class="python">
<b># from server2.py</b>

#------------------------------------------------------------------------------
class NetworkClientView:
        """We SEND events to the CLIENT through this object"""
        def __init__(self, evManager, sharedObjectRegistry):
                self.evManager = evManager
                self.evManager.RegisterListener( self )

                self.clients = []
                self.sharedObjs = sharedObjectRegistry


        #----------------------------------------------------------------------
        def Notify(self, event):
                if isinstance( event, ClientConnectEvent ):
                        self.clients.append( event.client )

                ev = event

                #don't broadcast events that aren't Copyable
                if not isinstance( ev, pb.Copyable ):
                        evName = ev.__class__.__name__
                        if not hasattr( network, "Copyable"+evName):
                                return
                        copyableClass = getattr( network, "Copyable"+evName)
                        ev = copyableClass( ev, self.sharedObjs )

                if ev.__class__ not in serverToClientEvents:
                        return 

                #NOTE: this is very "chatty".  We could restrict 
                #      the number of clients notified in the future
                for client in self.clients:
                        remoteCall = client.callRemote("ServerEvent", ev)


</pre></div>
The NetworkClientView keeps a reference to the server's registry that maps
object ID numbers to the actual objects. It also has a list of clients. The
objects in the clients list inherit from pb.Referenceable, so we can use the
callRemote() method, sending messages over the network. The
serverToClientEvents list is imported from network.py.
<p>NetworkClientView.Notify() is primarily interested in Copyable events. The
event passed in to Notify() might already be Copyable, due to the mixing in of
pb.Copyable in network.py. In that case, isinstance( ev, pb.Copyable ) returns
true. If it's not Copyable, there still might be a replacement class in the
network module, and we can check by prepending "Copyable" to the event's class
name because we used that naming convention for the replacement classes in
network.py.</p>
<p>As can be seen in NetworkClientView.Notify(), the server expects the client
to send it a remotely accessible object (like one that inherits from Twisted's
pb.Root) when the client connects. Thereafter, the server can use that object
to notify the client of events.</p>
<p>Now we'll (finally) get started on the client. From the point of view of
the client, the incoming messages from the server represent a Controller, so
we've got a NetworkServerController class in client2.py. As you might be
expecting, the client will also send events to the server through a View, the
NetworkServerView.</p>
<div class="codeblock">
<pre class="python">
<b>from client2.py</b>

<b>#------------------------------------------------------------------------------</b>
class NetworkServerView(pb.Root):
        """We SEND events to the server through this object"""

        ...

        <b>#----------------------------------------------------------------------</b>
        def Connected(self, server):
                self.server = server
                self.state = NetworkServerView.STATE_CONNECTED
                ev = ServerConnectEvent( server )
                self.evManager.Post( ev )

        ...

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                ev = event

                if isinstance( event, TickEvent ) \
                   and self.state == NetworkServerView.STATE_PREPARING:
                        self.state = NetworkServerView.STATE_CONNECTING
                        remoteResponse = pb.getObjectAt("localhost", 8000, 30)
                        remoteResponse.addCallback(self.Connected )

                ...
</pre></div>
On the first TickEvent that the NetworkServerView gets, it attempts to connect
to the server. When the connection is made, the Connected() method is called
with a reference to a server object that inherits from pb.Referenceable,
therefore the client can use it to remotely access the server. It also creates
a ServerConnectEvent.
<div class="codeblock">
<pre class="python">
<b>from client2.py</b>

<b>#------------------------------------------------------------------------------</b>
class NetworkServerController(pb.Referenceable):
        """We RECEIVE events from the server through this object"""
        def __init__(self, evManager, twistedReactor):
                self.evManager = evManager
                self.evManager.RegisterListener( self )

                self.reactor = twistedReactor

        <b>#----------------------------------------------------------------------</b>
        def remote_ServerEvent(self, event):
                self.evManager.Post( event )
                return 1

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                if isinstance( event, ServerConnectEvent ):
                        <b>#tell the server that we're listening to it and</b>
                        <b>#it can access this object</b>
                        event.server.callRemote("ClientConnect", self)
                if isinstance( event, TickEvent ):
                        <b>#PUMPING NETWORK</b>
                        self.reactor.iterate()

</pre></div>
The NetworkServerController gets notified of that ServerConnectEvent and uses
it to pass the server a reference to itself. Now the server can call the
remote_ServerEvent() method of the NetworkServerController. So both the server
and the client have references to remotely callable objects. This is the
channel through which they communicate.
<center><img src="diagram-channel.png" alt="example applicaton" width="442"
height="173"></center>
<h3><a name="complex">Sending Complex Objects</a></h3>
Theoretically, there should be only one model, the authoritative model on the
server, and the clients should just be Views and Controllers for that model.
This is not feasible in practice, however. For one, it is no simple matter to
keep references to <i>remote</i> model objects in the client's EventManager,
Views and Controllers. Another reason is that many events can be handled
entirely on the client side, and always sending them to the server would
create needless noise.
<p>We will create a PhonyModel on the client side who's state we will keep in
sync with the authoritative model on the server.</p>
<p>Here's the tricky part: how do we send complex objects like Players or
Charactors over the channel we've created? This is called
<b>serialization</b>. To serialize our objects, we need to do two things.</p>
<ul>
<li>Create a registry that maps unique IDs to game objects</li>
<li>For each class, have a way to change its data into numbers and strings,
and a way to change those back into useful objects</li>
</ul>
The unique IDs will be the result of the id() function called on the object in
question <i>on the server</i>. It must originate from the server so that it is
unique, otherwise we'd have multiple IDs for a single object.
<p>When events referencing complex objects get to the NetworkClientView on the
server, the objects are serialized starting in the constructor of the Copyable
event.</p>
<div class="codeblock">
<pre class="python">
<b>#from server3.py</b>

class NetworkClientView:
        ...

        def Notify(self, event):
                ...

                ev = event

                if not isinstance( ev, pb.Copyable ):
                        evName = ev.__class__.__name__
                        if not hasattr( network, "Copyable"+evName):
                                return
                        copyableClass = getattr( network, "Copyable"+evName)
                        if copyableClass not in serverToClientEvents:
                                return
                        <b>#It is here that serialization starts</b>
                        ev = copyableClass( ev, self.sharedObjs )

                elif ev.__class__ not in serverToClientEvents:
                        return 

                for client in self.clients:
                        self.RemoteCall( client, "ServerEvent", ev )
</pre></div>
Let's take a CharactorMoveEvent as an example. The above code will call
__init__() for CopyableCharactorMoveEvent.
<div class="codeblock">
<pre class="python">
<b>#from network.py</b>

class CopyableCharactorMoveEvent( pb.Copyable, pb.RemoteCopy):
        def __init__(self, event, registry ):
                self.name = "Copyable " + event.name
                self.charactorID = id( event.charactor )
                registry[self.charactorID] = event.charactor
</pre></div>
As you can see, the server won't send the actual object when it sends the
event, it will only send a unique integer ID. It also makes sure that there is
a mapping from that ID to the actual object in the registry.
<p>When the client is sent the CopyableCharactorMoveEvent, the PhonyModel
picks it up (the PhonyModel is the only object interested in events that start
with "Copyable").</p>
<div class="codeblock">
<pre class="python">
<b>#from client.py</b>

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                ...

                if isinstance( event, CopyableCharactorMoveEvent ):
                        charactorID = event.charactorID
                        if self.sharedObjs.has_key(charactorID):
                                charactor = self.sharedObjs[charactorID]
                                self.CharactorMoveCallback( charactor )
                        else:
                                charactor = self.game.players[0].charactors[0]
                                self.sharedObjs[charactorID] = charactor
                        remoteResponse = self.server.callRemote("GetObjectState", charactorID)
                        remoteResponse.addCallback(self.ObjStateReturned, self.CharactorMoveCallback)
</pre></div>
If the client has already received that object from the server,
self.sharedObjs.has_key() will return true, and it can grab a reference to the
object from the registry and carry on as normal. If it hasn't received that
object yet (as is the initial case), it must first create a placeholder
object, and then copy the state of the object on the server into this new
placeholder object. It does this by calling GetObjectState() with the unique
ID of the needed object.
<p>GetObjectState() basically just finds that object on the server (in this
example, the Charactor that has moved), and serializes it's data with a call
to getStateToCopy(). GetObjectState() returns the dict and the object ID that
was requested.</p>
<div class="codeblock">
<pre class="python">
<b>#from network.py</b>

<b>#------------------------------------------------------------------------------</b>
class CopyableCharactor:
        def getStateToCopy(self, registry):
                d = self.__dict__.copy()
                del d['evManager']

                if self.sector is None:
                        sID = None
                else:
                        sID = id( self.sector )
                d['sector'] = sID
                registry[sID] = self.sector

                return d

        def setCopyableState(self, stateDict, registry):
                neededObjIDs = []
                success = 1
                if stateDict['sector'] == None:
                        self.sector = None
                elif not registry.has_key( stateDict['sector'] ):
                        registry[stateDict['sector']] = Sector(self.evManager)
                        neededObjIDs.append( stateDict['sector'] )
                        success = 0
                else:
                        self.sector = registry[stateDict['sector']]

                return [success, neededObjIDs]
</pre></div>
The dict that getStateToCopy() returns contains all network-friendly data, so
it can be sent over the network.
<p>The client receives this information in the ObjStateReturned() function,
which is somewhat difficult to follow. In our example, the arguments passed to
ObjStateReturned() are the response from the GetObjectState() call to the
server ( [charactorID, charactorDict] ), and the desired final callback
CharactorMoveCallback() from the client.</p>
<div class="codeblock">
<pre class="python">
<b>#from client.py  --  this is where the "nextFn" argument comes from</b>

        def Notify(self, event):
                ...

                        remoteResponse = self.server.callRemote("GetObjectState", charactorID)
                        remoteResponse.addCallback(self.ObjStateReturned, self.CharactorMoveCallback)
</pre></div>
<div class="codeblock">
<pre class="python">
<b>#from server.py  --  this is where the "response" argument comes from</b>

        def remote_GetObjectState(self, objectID):
                ...

                return [objectID, objDict]
</pre></div>
<div class="codeblock">
<pre class="python">
<b>#from client.py</b>

        <b>#----------------------------------------------------------------------</b>
        def ObjStateReturned(self, response, nextFn=None):
                """this is a callback that is called in response to 
                invoking GetObjectState on the server"""

                if response[0] == 0:
                        print "GOT ZERO -TODO: better error handler here"
                        return None
                objID = response[0]
                objDict = response[1]
                obj = self.sharedObjs[objID]

                retval = obj.setCopyableState(objDict, self.sharedObjs)
                if retval[0] == 1:
                        <b>#we successfully set the state and no further objects</b>
                        <b>#are needed to complete the current object</b>
                        if objID in self.neededObjects:
                                self.neededObjects.remove(objID)

                else:
                        <b>#to complete the current object, we need to grab the</b>
                        <b>#state from some more objects on the server.  The IDs</b>
                        <b>#for those needed objects were passed back in retval[1]</b>
                        for neededObjID in retval[1]:
                                if neededObjID not in self.neededObjects:
                                        self.neededObjects.append(neededObjID)
        
                self.waitingObjectStack.append( (obj, objDict, nextFn) )

                self.GetAllNeededObjects()
</pre></div>
Blah blah...
<div class="codeblock">
<pre class="python">
<b>#from client.py</b>

        <b>#----------------------------------------------------------------------</b>
        def GetAllNeededObjects(self):
                if len(self.neededObjects) == 0:
                        <b>#this is the recursion-ending condition.  If there are</b>
                        <b>#no more objects needed to be grabbed from the server</b>
                        <b>#then we can try to setCopyableState on them again and</b>
                        <b>#we should now have all the needed objects, ensuring</b>
                        <b>#that setCopyableState succeeds</b>
                        while self.waitingObjectStack:
                                t = self.waitingObjectStack.pop()
                                obj = t[0]
                                objDict = t[1]
                                fn = t[2]
                                retval = obj.setCopyableState(objDict, self.sharedObjs)
                                if retval[0] == 0:
                                        print "WEIRD!! - TODO:better Error here"

                                if fn:
                                        fn( obj )
                        return

                <b>#still in the recursion step.  Try to get the object state for</b>
                <b>#the objectID on the end of the stack.  Note that the recursion</b>
                <b>#is done via a deferred, which may be confusing </b>
                nextID = self.neededObjects[len(self.neededObjects)-1]
                remoteResponse = self.server.callRemote("GetObjectState", nextID)
                remoteResponse.addCallback(self.ObjStateReturned)
</pre></div>
<p>Here is a flowchart that summarizes the actions taken when the client gets
an event containing a complex object.</p>
<center><img src="diagram-serialization-flowchart.png" alt=
"flowchart of client event reception" width="400" height="452"></center>
<p>Notice that we must make sure that the event we send over the network has
enough information to update the client with any relevant changes to the state
of the server. The client may already have a local version of an object, but
if that object has <i>changed</i>, the client still has to call
GetObjectState(), as is demonstrated with the CharactorMoveEvent.</p>
<p>With that in mind, a question is raised: where do we put the intelligence
do determine what object states we need to retrieve? Right now, we've put all
this logic in PhonyModel.Notify() <span class="todo">[TODO: is this the best
place? what about inside Copyable events?]</span></p>
<p><span class="todo">[TODO: more details esp. regarding
PhonyModel]</span></p>
<h2><a name="problems">More Problems</a></h2>
<p>The previous discussion is a good start and provides some usefull code.  I
encourage you to play around with it and see if you can get your game sending
objects back and forth.  As your code becomes more complex, you will run into
some more problems:
<ol>
<li>What if we don't have enough information to call __init__ for 
some attributes in setCopyableState() ?</li>
<li>What if we don't know the specific subclass for an attribute in 
setCopyableState() ?</li>
</ol>
<p>To clarify, here's an example of when an issue like this might come up.
Lets say we write a game where two Penguins fight each other.  Each Penguin
has a weapon, and every weapon is initialized with a name, like "Deathbringer"
or "Destroy-o-Matic", or "Patricia".
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class Weapon:
	def __init__( self, evManager, name )
		self.evManager = evManager
		self.name = name
</pre></div>
<p>CopyablePenguin would thus look something like this:
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class CopyablePenguin:
        def getStateToCopy(self, registry):
                d = self.__dict__.copy()
                del d['evManager']

		wID = id( self.weapon )
		registry[wID] = self.weapon
		d['weapon'] = wID
                                                                                
                return d
</pre></div>
We would naievely start writing the corresponding setCopyableState function:
<div class="codeblock">
<pre class="python">
        def setCopyableState(self, stateDict, registry):
		neededObjIDs = []
		success = 1

		wID = stateDict['weapon']
		if not registry.has_key( wID ):
			<b>#registry didn't have the object, so create a new one</b>
			self.weapon = Weapon( self.evManager,
			<b>#WELL CRAP!  I don't yet know what its name is,</b>
			<b>so how am I going to initialize it?</b>
</pre></div>

Furthermore, lets say that Weapons are of one of three subclasses, 
either Slingshot, Rifle, or Nuke.  Then we have even more difficulties with
setCopyableState:
<div class="codeblock">
<pre class="python">
		...
		wID = stateDict['weapon']
		if not registry.has_key( wID ):
			<b>#registry didn't have the object, so create a new one</b>
			self.weapon = <i>???</i>
			<b>#MORE CRAP!  I don't even know what class of object</b>
			<b>it should be!</b>
</pre></div>

<p>We can solve this problem with a Placeholder object that is very similar to
the <b>Lazy Proxy</b> design pattern.
<p>...
<span class="todo">[TODO: finish this section]</span>


<h2><a name="reconnect">Reconnecting After A Drop</a></h2>
As is wont with the internet, sometimes a connection gets accidentally
dropped.
<div class="sourceLinks">Here is our example that handles dropping the
connection: <a href="example3.tar.gz">example3.tar.gz</a></div>
<span class="todo">[TODO: more details]</span>
<h2><a name="multiplayer">Multiplayer</a></h2>
<h3><a name="nonnetworked">Non-Networked Multiplayer</a></h3>
We'll start off by creating a 2-player game that runs locally, not over the
network. Our loosely coupled architecture allows us to do this, and it's a
great advantage to be able to develop your ideas first and worry about network
issues later.
<pre>
- Player no longer generated by Game.__init__()
- Player comes from external source
- Player must be uniquely identifiable to the server
- Queue needed for EventManager

- Convention: "Request" events are NEVER generated inside the model, always generated by the UI
</pre>
<span class="todo">[TODO]</span>
<h3><a name="networked">Networked Multiplayer</a></h3>
<span class="todo">[TODO]</span>
<div class="sourceLinks">Here is our example of networked multiplayer:
<a href="example4.tar.gz">example4.tar.gz</a></div>
<p>But here you may notice that Player One's client can control Player Two's
charactor. This is obviously not desireable. We want the server to reject any
request where the player instance contained in the request is not an instance
created by that client. One way to solve this problem is for the the client to
create a random number or <i>password</i> when it sends a PlayerJoinRequest.
Then, in every subsequent client-generated event that references a player, it
includes that password. The server can store the passwords as they come in,
and check that they match for every event that references a player
instance.</p>
<p>There is another way, and it is conveniently built into Twisted. We'll take
a look at it in the next chapter. <span class="todo">[TODO ... or
not]</span></p>
<p>
<!-- ====================================================================== --></p>
<h1>PART 3</h1>
<h1>Graphical User Interface</h1>
<h2>What Is A Widget</h2>
A widget is the elemental object in a GUI. A widget can be a button, a label,
a text entry field, etc. A widget can even contain other widgets, like a
toolbar, or a menubar, or even a simple horizontal box.
<p>You can get as complicated as you like when creating your GUI engine, but
this tutorial will focus only on some simple widgets. Here are the ones we
will implement:</p>
<ul>
<li>label</li>
<li>button</li>
<li>text-entry field</li>
<li><span class="todo">[TODO ... scrollbox?]</span></li>
</ul>
All widgets share a small amount of behaviour, so we have an abstract Widget
class that inherits from Sprite. Widgets can be focused and unfocused, and
have a 'dirty' flag so that they can be redrawn when needed, and not on every
single call to update().
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class Widget(pygame.sprite.Sprite):
        def __init__(self, evManager, container=None):
                pygame.sprite.Sprite.__init__(self)

                self.evManager = evManager
                self.evManager.RegisterListener( self )

                self.container = container
                self.focused = 0
                self.dirty = 1

        <b>#----------------------------------------------------------------------</b>
        def SetFocus(self, val):
                self.focused = val
                self.dirty = 1

        <b>#----------------------------------------------------------------------</b>
        def kill(self):
                self.container = None
                del self.container
                pygame.sprite.Sprite.kill(self)

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                if isinstance( event, GUIFocusThisWidgetEvent ) \
                  and event.widget is self:
                        self.SetFocus(1)

                elif isinstance( event, GUIFocusThisWidgetEvent ) \
                  and self.focused:
                        self.SetFocus(0)
</pre></div>
<h3>Label</h3>
Probably the simplest widget is a label. It is basically just a holder for
some text.
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class LabelSprite(Widget):
        def __init__(self, evManager, text, container=None):
                Widget.__init__( self, evManager, container)

                self.color = (200,200,200)
                self.font = pygame.font.Font(None, 30)
                self.__text = text
                self.image = self.font.render( self.__text, 1, self.color)
                self.rect  = self.image.get_rect()

        <b>#----------------------------------------------------------------------</b>
        def SetText(self, text):
                self.__text = text
                self.dirty = 1

        <b>#----------------------------------------------------------------------</b>
        def update(self):
                if not self.dirty:
                        return

                self.image = self.font.render( self.__text, 1, self.color )
                self.dirty = 0
</pre></div>
<h3>Button</h3>
A button is also a very simple widget. It is just an image that can be
clicked, and when it is clicked, it fires off an event. For simplicity's sake
the image is just some rendered text, but it could be anything.
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class ButtonSprite(Widget):
        def __init__(self, evManager, text, container=None, onClickEvent=None ):
                Widget.__init__( self, evManager, container)

                self.font = pygame.font.Font(None, 30)
                self.text = text
                self.image = self.font.render( self.text, 1, (255,0,0))
                self.rect  = self.image.get_rect()

                self.onClickEvent = onClickEvent

        <b>#----------------------------------------------------------------------</b>
        def update(self):
                if not self.dirty:
                        return

                if self.focused:
                        color = (255,255,0)
                else:
                        color = (255,0,0)
                self.image = self.font.render( self.text, 1, color)
                <b>#self.rect  = self.image.get_rect()</b>

                self.dirty = 0

        <b>#----------------------------------------------------------------------</b>
        def Connect(self, eventDict):
                for key,event in eventDict.iteritems():
                        try:
                                self.__setattr__( key, event )
                        except AttributeError:
                                print "Couldn't connect the ", key
                                pass


        <b>#----------------------------------------------------------------------</b>
        def Click(self):
                self.dirty = 1
                if self.onClickEvent:
                        self.evManager.Post( self.onClickEvent )

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):
                if isinstance( event, GUIPressEvent ) and self.focused:
                        self.Click()

                elif isinstance( event, GUIClickEvent ) \
                  and self.rect.collidepoint( event.pos ):
                        self.Click()

                elif isinstance( event, GUIMouseMoveEvent ) \
                  and self.rect.collidepoint( event.pos ):
                        ev = GUIFocusThisWidgetEvent(self)
                        self.evManager.Post( ev )

                Widget.Notify(self,event)

</pre></div>
<h3>Text Box</h3>
A text box is a little bit more complicated but still easy to understand. It
is basically a rectangle into which text can be typed. When it gets focus it
shows a little vertical bar (|) and starts responding to keypress events.
<div class="codeblock">
<pre class="python">
<b>#------------------------------------------------------------------------------</b>
class TextBoxSprite(Widget):
        def __init__(self, evManager, width, container=None ):
                Widget.__init__( self, evManager, container)

                self.font = pygame.font.Font(None, 30)
                linesize = self.font.get_linesize()

                self.rect = pygame.Rect( (0,0,width, linesize +4) )
                boxImg = pygame.Surface( self.rect.size ).convert_alpha()
                color = (0,0,100)
                pygame.draw.rect( boxImg, color, self.rect, 4 )

                self.emptyImg = boxImg.convert_alpha()
                self.image = boxImg

                self.text = ''
                self.textPos = (22, 2)

        <b>#----------------------------------------------------------------------</b>
        def update(self):
                if not self.dirty:
                        return

                text = self.text
                if self.focused:
                        text += '|'

                textColor = (255,0,0)
                textImg = self.font.render( text, 1, textColor )
                self.image.blit( self.emptyImg, (0,0) )
                self.image.blit( textImg, self.textPos )

                self.dirty = 0

        <b>#----------------------------------------------------------------------</b>
        def Click(self):
                self.focused = 1
                self.dirty = 1

        <b>#----------------------------------------------------------------------</b>
        def SetText(self, newText):
                self.text = newText
                self.dirty = 1

        <b>#----------------------------------------------------------------------</b>
        def Notify(self, event):

                if isinstance( event, GUIPressEvent ) and self.focused:
                        self.Click()

                elif isinstance( event, GUIClickEvent ) \
                  and self.rect.collidepoint( event.pos ):
                        self.Click()

                elif isinstance( event, GUIClickEvent ) \
                  and self.focused:
                        self.SetFocus(0)

                elif isinstance( event, GUIMouseMoveEvent ) \
                  and self.rect.collidepoint( event.pos ):
                        ev = GUIFocusThisWidgetEvent(self)
                        self.evManager.Post( ev )

                elif isinstance( event, GUIKeyEvent ) \
                  and self.focused:
                        newText = self.text + event.key
                        self.SetText( newText )

                elif isinstance( event, GUIControlKeyEvent ) \
                  and self.focused and event.key == K_BACKSPACE:
                        <b>#strip of last character</b>
                        newText = self.text[:( len(self.text) - 1 )]
                        self.SetText( newText )

                Widget.Notify(self,event)
</pre></div>
<h2>GUI Screens</h2>
<center><img src="diagram-visualstages.png" alt=
"the visualstages of an example game" width="362" height="382"></center>
<p>Above is a diagram showing some common uses of a Graphical User Interface
in games. In each of the above screens, there is a blue section representing
buttons or other widgets. It will also serve as the idea for our next example
application, "Fool The Bar".</p>
<h3>Menu</h3>
<img src="diagram-gui-menu.png" alt="menu example" class="internal" width=
"100" height="82"> The Menu GUI is the first thing seen when the program
starts up. It is usually just a collection of buttons, most often things like
"New Game", "Quit" and "Options". Sometimes there are multiple kinds of
"Options" choices.
<h3>Options</h3>
<img src="diagram-gui-options.png" alt="options example" class="internal"
width="100" height="84"> The Options GUI is where the user sets their
preferences or adds their personal information. It is usually text labels with
adjacent fields where the user can change / add the values.
<h3>Main</h3>
<img src="diagram-gui-main.png" alt="main example" class="internal" width=
"100" height="84"> The Main GUI is where the game actually gets played. Few
games have much in common when it comes to the Main GUI. However, many games
have a "function bar" or a "shortcut bar" along some edge that is made up of
buttons or other widgets.
<h3>Cutscene</h3>
<img src="diagram-gui-cutscene.png" alt="cutscene example" class="internal"
width="100" height="84"> A Cutscene is part of the game where direct control
is taken away and part of the game's story is presented. This can be done by
playing a movie, or by presenting text with accompanying pictures. User input
is usually limited to a few choices like "skip" or "continue".
<h3>Dialog</h3>
<img src="diagram-gui-dialog.png" alt="dialog example" class="internal" width=
"100" height="84"> A Dialog is one of the more tricky things to do in a game.
It is usually a rectangle that pops up over the Main GUI containing buttons,
text, or other widgets (like an RPG "inventory" dialog). While the Dialog is
up, the presentation of the Main GUI is usually not interrupted (though it
could be). Things still may move around in the background, but the Dialog is
understood to have <i>focus</i>. For instance, if a "chat" dialog is present,
the keypresses that usually make a Charactor move (ie "WASD") will now go only
to the "chat" dialog so the user can type in a message. If a "yes/no" dialog
has popped up such that the "no" button is over a charactor on the screen, and
the user clicks the "no" button, that click should not select the charactor
underneath, it should <i>only</i> press the "no" button.
<div class="sourceLinks">Here is the source code to our example application,
Fool The Bar: <a href="foolbar.tar.gz">foolbar.tar.gz</a></div>
<h1><a name="faq">FAQ</a></h1>
<ul class="faq">
<li class="q">What license is all this code under?</li>
<li class="a">Unless otherwise stated, everything here is in the Public
Domain.</li>
<li class="q">Why do you use <code>from module import *</code>? Don't you know
that's bad coding style</li>
<li class="a">Yeah, my bad. I promise i'll clean all those up before i declare
this "finished".</li>
<li class="q">Why don't you use Twisted's Cacheable? It seems like you're just
reimplementing it.</li>
<li class="a">I am a bit of a newbie when it comes to Twisted. I read a bit
about the Cacheable stuff, but it seemed to me I'd have to make the classes of
my Model be Cacheable, and I didn't want the network code to be coupled with
my model code. And seeing as I would have to write serialization code even if
I used Cacheable, I just bulldozed ahead. Would it be possible to use
Cacheable without coupling it with the Model code? Could someone who is
familiar with Twisted point me in the right direction?</li>
</ul>
</body>
</html>
